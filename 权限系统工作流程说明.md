
# 权限管理系统工作流程说明
## 目录
1. 系统架构
2. 权限模型
3. 开发规范
4. 示例
5. 其他注意事项

## 1. 系统架构
权限管理系统采用基于角色的访问控制（RBAC）模型。主要组件包括：
- **Permission（权限）**：定义具体的操作权限，包含名称、代码和描述。
- **Role（角色）**：一组权限的集合，包含名称、描述，并与多个权限关联。
- **UserRole（用户-角色关联）**：作为用户和角色之间的中间表，实现用户与角色的多对多关系。
## 2. 权限模型
### 2.1 数据模型
- **Permission**：
```python
class Permission(models.Model):
    name = models.CharField(max_length=100)
    codename = models.CharField(max_length=100, unique=True)
    description = models.TextField(blank=True)

    def __str__(self):
        return self.name
```
- **Role**：
```python
class Role(models.Model):
    name = models.CharField(max_length=100)
    permissions = models.ManyToManyField(Permission)
    description = models.TextField(blank=True)
    users = models.ManyToManyField(
        settings.AUTH_USER_MODEL,
        through='UserRole',
        related_name='roles'
    )

    def __str__(self):
        return self.name
```
- **UserRole**：
```python
class UserRole(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    role = models.ForeignKey(Role, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ['user', 'role']
```

### 2.2 权限代码规范
- 权限代码统一使用 `snake_case` 格式，直接描述操作，如：
    - `view_all_employees`：查看所有员工的权限。
    - `create_employee`：创建员工的权限。
    - `confirm_transfer`：确认调动的权限。
- 所有权限代码统一定义在 `constants.py` 中，避免在代码中硬编码，便于维护和管理。


## 3. 开发规范
### 3.1 统一定义权限和角色
- **权限定义**
```python
# permissions/constants.py
PERMISSION_CODES = {
    'employee': {
        'view_all': 'view_all_employees',
        'view_company': 'view_company_employees',
        'view_project': 'view_project_employees',
        'create': 'create_employee',
        'update': 'update_employee',
        'delete': 'delete_employee',
        'initiate_transfer': 'initiate_transfer',
        'confirm_transfer': 'confirm_transfer',
        'initiate_resignation': 'initiate_resignation',
        'confirm_resignation': 'confirm_resignation',
    }
}
```

- **角色与权限的对应关系**

```python
ROLE_PERMISSIONS = {
    '总公司管理员': [
        PERMISSION_CODES['employee']['view_all'],
        PERMISSION_CODES['employee']['create'],
        PERMISSION_CODES['employee']['update'],
        PERMISSION_CODES['employee']['delete'],
        PERMISSION_CODES['employee']['initiate_transfer'],
        PERMISSION_CODES['employee']['confirm_transfer'],
        PERMISSION_CODES['employee']['initiate_resignation'],
        PERMISSION_CODES['employee']['confirm_resignation'],
    ],
    '公司管理员': [
        PERMISSION_CODES['employee']['view_company'],
        PERMISSION_CODES['employee']['confirm_transfer'],
    ],
    '项目负责人': [
        PERMISSION_CODES['employee']['view_project'],
        PERMISSION_CODES['employee']['confirm_transfer'],
    ],
}
```

### 3.2 权限的初始化与同步

- **迁移脚本初始化**
在 `0002_initialize_permissions.py` 中，通过读取 `constants.py` 定义的权限和角色，初始化到数据库：

```python
def initialize_permissions_and_roles(apps, schema_editor):
    Permission = apps.get_model('permissions', 'Permission')
    Role = apps.get_model('permissions', 'Role')

    # 创建权限
    permissions = {}
    for category_perms in PERMISSION_CODES.values():
        for codename in category_perms.values():
            permission, created = Permission.objects.get_or_create(
                codename=codename,
                defaults={'name': codename.replace('_', ' ').title()}
            )
            permissions[codename] = permission

    # 创建角色并分配权限
    for role_name, perm_codenames in ROLE_PERMISSIONS.items():
        role, created = Role.objects.get_or_create(name=role_name)
        role_perms = [permissions[code] for code in perm_codenames]
        role.permissions.set(role_perms)
```
### 3.3 使用装饰器进行权限验证
- **权限装饰器**
使用 `@permission_required` 装饰器，在视图函数或方法中检查用户权限：

```python
from permissions.decorators import permission_required

@permission_required('view_all_employees')
def view_all_employees(request):
    # 处理逻辑
    pass
```

### 3.4 手动检查权限
- **手动检查**
在代码中手动检查用户权限：

```python
if 'update_employee' in request.user_permissions:
    # 执行更新操作
    pass
else:
    raise PermissionDenied("您没有执行此操作的权限。")
```

### 3.5 权限缓存机制
- **缓存用户权限**
为提高性能，使用缓存机制（如 Redis 或内存缓存）缓存用户的权限集合：

```python
# permissions/services.py

def get_user_permissions(user):
    cache_key = f'user_permissions_{user.id}'
    permissions = cache.get(cache_key)
    
    if permissions is None:
        roles = UserRole.objects.filter(user=user).select_related('role')
        permissions = set()
        for user_role in roles:
            role_perms = user_role.role.permissions.values_list('codename', flat=True)
            permissions.update(role_perms)
        cache.set(cache_key, permissions, 3600)  # 缓存1小时
    
    return permissions
```

- **中间件设置**
在中间件中获取用户权限，并添加到请求对象中：

```python
# permissions/middleware.py

class PermissionMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        if request.user.is_authenticated:
            request.user_permissions = get_user_permissions(request.user)
        else:
            request.user_permissions = set()
        response = self.get_response(request)
        return response
```

### 3.6 前后端协作
- **注册与登录**
    - 前端在注册时，需要从后端获取角色列表。
    - 注册时提交 `username`、`password`、`role_id`、`company`、`project` 等信息。
    - 后端在 `RegisterSerializer` 中创建用户并关联角色。

- **权限控制**
    - 前端根据用户的权限，控制界面元素的显示与操作。
    - 登录后，前端从后端获取用户信息和权限，存储在本地以便使用。


## 4. 示例
### 示例1：定义权限和角色
```python
# permissions/constants.py

PERMISSION_CODES = {
    'employee': {
        'view_all': 'view_all_employees',
        # 其他权限...
    }
}

ROLE_PERMISSIONS = {
    '总公司管理员': [
        PERMISSION_CODES['employee']['view_all'],
        # 其他权限...
    ],
    # 其他角色...
}
```
### 示例2：权限初始化迁移脚本

```python
# permissions/migrations/0002_initialize_permissions.py

from django.db import migrations
from permissions.constants import PERMISSION_CODES, ROLE_PERMISSIONS

def initialize_permissions_and_roles(apps, schema_editor):
    # 初始化逻辑...

class Migration(migrations.Migration):

    dependencies = [
        ('permissions', '0001_initial'),
    ]

    operations = [
        migrations.RunPython(initialize_permissions_and_roles),
    ]
```
### 示例3：使用装饰器检查权限
```python
from permissions.decorators import permission_required

@permission_required('view_company_employees')
def view_company_employees(request):
    # 处理逻辑
    pass
```

### 示例4：在视图中根据权限过滤数据
```python
class EmployeeViewSet(viewsets.ModelViewSet):
    queryset = Employee.objects.all()
    serializer_class = EmployeeSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user_permissions = self.request.user_permissions

        if PERMISSION_CODES['employee']['view_all'] in user_permissions:
            queryset = self.queryset.filter(employment_status__in=['在岗', '待岗'])
        elif PERMISSION_CODES['employee']['view_company'] in user_permissions:
            queryset = self.queryset.filter(
                company=self.request.user.company,
                employment_status__in=['在岗', '待岗']
            )
        elif PERMISSION_CODES['employee']['view_project'] in user_permissions:
            queryset = self.queryset.filter(
                project=self.request.user.project,
                employment_status__in=['在岗', '待岗']
            )
        else:
            queryset = Employee.objects.none()
        return queryset
```

### 示例5：注册序列化器
```python
class RegisterSerializer(serializers.ModelSerializer):
    role_id = serializers.IntegerField(write_only=True, required=True)

    class Meta:
        model = User
        fields = ['username', 'password', 'role_id', 'company', 'project']
        extra_kwargs = {'password': {'write_only': True}}

    def create(self, validated_data):
        from permissions.models import Role, UserRole  # 避免顶层导入
        
        role_id = validated_data.pop('role_id')
        user = User.objects.create_user(
            username=validated_data['username'],
            password=validated_data['password'],
            company=validated_data.get('company'),
            project=validated_data.get('project'),
        )
        role = Role.objects.get(id=role_id)
        UserRole.objects.create(user=user, role=role)
        return user
```

### 示例6：前端注册页面（简化版）
```typescript
// RegisterPage.tsx

useEffect(() => {
  fetchRoles()
    .then(response => setRoles(response.data.roles))
    .catch(() => console.error('Failed to fetch roles'));
}, []);

const handleRegister = async (e: React.FormEvent) => {
  e.preventDefault();
  if (password !== confirmPassword) {
    setError('两次输入的密码不一致');
    return;
  }
  
  const data = {
    username,
    password,
    role_id: selectedRoleId,
    company,
    project,
  };

  try {
    const response = await register(data);
    router.push('/login');
  } catch (error) {
    setError('注册失败，请重试');
  }
};
```

## 5. 其他注意事项
### 5.1 避免循环依赖
- 跨应用引用模型时，使用 `get_user_model()` 或 `settings.AUTH_USER_MODEL`，避免直接导入。
- 在需要跨应用导入时，尽量在函数或方法内部进行导入。

### 5.2 权限缓存更新
- 当用户的角色或权限发生变更时，需要清除对应的缓存，以确保权限信息是最新的。

### 5.3 日志与调试
- 在开发环境中，可添加日志输出用户和权限信息，帮助调试。
- 在生产环境中，注意日志的级别，避免泄露敏感信息。

### 5.4 代码规范
- 遵循代码规范和最佳实践，提高代码的可读性和可维护性。
- 在提交代码前，请确保代码经过格式化和静态检查。

### 5.5 前后端协作
- 前后端需要就接口格式、数据结构和错误处理达成一致。
- 定期沟通，确保权限和角色的更新及时同步，避免不一致。
